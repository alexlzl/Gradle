apply plugin: 'com.android.application'

android {
    compileSdkVersion 26



    defaultConfig {
        applicationId "com.example.myapplication"
        minSdkVersion 15
        targetSdkVersion 26
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"

    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }

}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])

    implementation 'com.android.support:appcompat-v7:26.0.0-beta1'
    implementation 'com.android.support.constraint:constraint-layout:1.0.2'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:0.5'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:2.2.2'
}

/**
 * 调用Project的task()方法创建Task===========方式1
 * 这里的“<<”表示追加的意思，即向hello中加入执行过程。我们还可以使用doLast来达到同样的效果：
 */

task hello1 << {
    println 'hello1'
}

task hello2 {
    doLast {
        println 'hello2'
    }
}
/**
 * 另外，如果需要向Task的最前面加入执行过程，我们可以使用doFirst：
 */

task hello3 {
    doFirst {
        println 'hello3'
    }
}
/**
 * 在上面的3个例子中，Gradle的DSL向我们展示了一种非常自然的风格来创建Task，
 * 而事实上这些都只是一种内部DSL，也即必须符合groovy的语法要求。
 * 上面的task关键字实际上是一个方法调用，该方法属于Project。Project中存在多个重载的task()方法。
 * 和Ruby等动态语言一样，在调用groovy方法时，我们不用将参数放在括号里面。
 　以上我们自定义的3个Task都位于TaskContainer中，Project中的tasks属性即表示该TaskContainer。
 为此，我们可以新建一个Task来显示这些信息：
 */

/**
 * 通过TaskContainer的create()方法创建Task 创建Task===========方式2
 * 在上文中我们讲到，通过task()方法创建的Task都被存放在了TaskContainer中，
 * 而Project又维护了一个TaskContainer类型的属性tasks，那么我们完全可以直接向TaskContainer里面添加Task。
 * 查查TaskContainer的API文档可以发现，TaskContainer向我们提供了大量重载的create()方法用于添加Task。
 */
tasks.create(name: 'hello4') << {
    println 'hello4'
}

/**
 * 声明Task之间的依赖关系=========================
 * Task之间是可以存在依赖关系，比如TaskA依赖TaskB，那么在执行TaskA时，Gradle会先执行TaskB，再执行TaskA。
 * 我们可以在定义一个Task的同时声明它的依赖关系：
 */

task hello5(dependsOn: hello4) << {
    println 'hello5'
}

/**
 * 当然，我们也可以在定义Task之后再声明依赖：
 */
task hello6 << {
    println 'hello6'
}

hello6.dependsOn hello5

/**
 * 配置Task================方式1=================task内部
 * 一个Task除了执行操作之外，还可以包含多个Property，其中有Gradle为每个Task默认定义的Property，比如description，logger等。
 * 另外，每一个特定的Task类型还可以含有特定的Property，比如Copy的from和to等。当然，我们还可以动态地向Task中加入额外的Property。
 * 在执行一个Task之前，我们通常都需要先设定Property的值，Gradle提供了多种方法设置Task的Property值。
 */
task hello7 << {
    description = "this is hello7"
    println description
}

/**
 * 我们还可以通过闭包的方式来配置一个已有的Task：方式2===============闭包配置
 */

task hello8 << {
    println description
}

hello8 {
    description = "this is hello8"
}

/**
 * 需要注意的是，对hello8的description设置发生在创建该Task之后，在执行“gradle hello8”时，命令行依然可以打印出正确的“this is hello8”，
 * 这是因为Gradle在执行Task时分为两个阶段，首先是配置阶段，然后才是实际执行阶段。所以在执行hello8之前，Gradle会扫描整个build.gradle文档，
 * 将hello8的description设置为“this is hello8”，然后执行hello8，此时hello8的description已经包含了设置后的值。
 　我们还可以通过调用Task的configure()方法完成Property的设置：
 */
task hello9 << {
    println description
}
/**
 * 方式3====================configure
 */
hello9.configure {
    description = "this is hello9"
}