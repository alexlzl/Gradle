apply plugin: 'com.android.application'

android {
    compileSdkVersion 26



    defaultConfig {
        applicationId "com.example.myapplication"
        minSdkVersion 15
        targetSdkVersion 26
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"

    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }

}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])

    implementation 'com.android.support:appcompat-v7:26.0.0-beta1'
    implementation 'com.android.support.constraint:constraint-layout:1.0.2'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:0.5'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:2.2.2'
}

/**
 * 调用Project的task()方法创建Task===========方式1
 * 这里的“<<”表示追加的意思，即向hello中加入执行过程。我们还可以使用doLast来达到同样的效果：
 */

task hello1 << {
    println 'hello1'
}

task hello2 {
    doLast {
        println 'hello2'
    }
}
/**
 * 另外，如果需要向Task的最前面加入执行过程，我们可以使用doFirst：
 */

task hello3 {
    doFirst {
        println 'hello3'
    }
}
/**
 * 在上面的3个例子中，Gradle的DSL向我们展示了一种非常自然的风格来创建Task，
 * 而事实上这些都只是一种内部DSL，也即必须符合groovy的语法要求。
 * 上面的task关键字实际上是一个方法调用，该方法属于Project。Project中存在多个重载的task()方法。
 * 和Ruby等动态语言一样，在调用groovy方法时，我们不用将参数放在括号里面。
 　以上我们自定义的3个Task都位于TaskContainer中，Project中的tasks属性即表示该TaskContainer。
 为此，我们可以新建一个Task来显示这些信息：
 */


/**
 * 通过TaskContainer的create()方法创建Task 创建Task===========方式2
 * 在上文中我们讲到，通过task()方法创建的Task都被存放在了TaskContainer中，
 * 而Project又维护了一个TaskContainer类型的属性tasks，那么我们完全可以直接向TaskContainer里面添加Task。
 * 查查TaskContainer的API文档可以发现，TaskContainer向我们提供了大量重载的create()方法用于添加Task。
 */
tasks.create(name: 'hello4') << {
    println 'hello4'
}

/**
 * 声明Task之间的依赖关系=========================
 * Task之间是可以存在依赖关系，比如TaskA依赖TaskB，那么在执行TaskA时，Gradle会先执行TaskB，再执行TaskA。
 * 我们可以在定义一个Task的同时声明它的依赖关系：
 */

task hello5(dependsOn:hello4) << {
    println 'hello5'
}

/**
 * 当然，我们也可以在定义Task之后再声明依赖：
 */
task hello6 << {
    println 'hello6'
}

hello6.dependsOn hello5